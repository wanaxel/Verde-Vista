var ScrollReveal = function() {
    "use strict";

    var defaults = {
        delay: 0,
        distance: "0",
        duration: 600,
        easing: "cubic-bezier(0.5, 0, 0, 1)",
        interval: 0,
        opacity: 0,
        origin: "bottom",
        rotate: {
            x: 0, 
            y: 0, 
            z: 0
        },
        scale: 1,
        cleanup: false,
        container: document.documentElement,
        desktop:true,
        mobile: true,
        reset: false,
        useDelay: "always",
        viewFactor: 0,
        viewOffset: {
            top: 0, 
            right: 0, 
            bottom: 0, 
            left: 0
        },
        afterReset: function(){},
        afterReveal: function(){},
        beforeReset: function(){},
        beforeReveal :function(){}
    };
    var supportCheck = {
        success: function(){
            if (document.body)
                document.body.style.height = "100%";
            
            else 
                document.addEventListener("DOMContentLoaded", function () {document.body.style.height = "100%"; });
        },
        
        failure: function(){
            return document.documentElement.classList.remove("sr"),
            {
                clean:function(){},
                destroy:function(){},
                reveal:function(){},
                sync:function(){},
                get noop(){
                    return!0
                }
            }
        }
    };
    
    function isNode(obj) {
        return typeof window.Node === "object" ?
            obj instanceof window.Node :
            obj !== null &&
            typeof obj === "object" &&
            typeof obj.nodeType === "number" &&
            typeof obj.nodeName === "string";
    }   
    
    function u(object, t) {
        if (void 0 === t && (t = document), object instanceof Array)
            return object.filter(isNode);
    
        if (isNode(object))
            return [object];
    
        if (supportCheck === object) {
            i = Object.prototype.toString.call(supportCheck);
            if ("object" == typeof window.NodeList) {
                if (supportCheck instanceof window.NodeList)
                    return Array.prototype.slice.call(object);
            } else {
                if (null !== supportCheck && "object" == typeof supportCheck && "number" == typeof supportCheck.length && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(i) && (0 === supportCheck.length || isNode(supportCheck[0])))
                    return Array.prototype.slice.call(object);
            }
        }
    
        var supportCheck, i;
        if ("string" == typeof object)
            try {
                var defaults = t.querySelectorAll(object);
                return Array.prototype.slice.call(defaults)
            }
        catch (object) {
            return []
        }
        return []
    }
    
    function isObject(object){
        return ( 
            object !== null && 
            object instanceof Object && 
            (object.constructor === Object || 
                "[object Object]" === Object.prototype.toString.call(object))
        )
    }
    
    function forEach(object, i) {
        if (isObject(object)) {
            Object.keys(object).forEach(function (key) {
                return i(object[key], key, object);
            });
        } 
        
        else if (Array.isArray(object)) {
            object.forEach(function (item, index) {
                return i(item, index, object);
            });
        } 

        else
            throw new TypeError("Expected either an array or object literal.");
    }
        
    function debuglog(message) {
        var args = [].slice.call(arguments, 1);
        if (ScrollReveal.debug && console) {
            var logMessage = "%cScrollReveal: " + message;
            args.forEach(function (arg) {
                return (logMessage += "\n â€” " + arg);
            });
            console.debuglog(logMessage, "color: #ea654b;");
        }
    }
            
    function t() {
        var _this = this;
        try {
            forEach(filterNodes("[data-sr-id]"), function (element) {
                var id = parseInt(element.getAttribute("data-sr-id"));
                if (id !== null) {
                    var elementData = _this.store.elements[id];
                    if (elementData.callbackTimer) {
                        window.clearTimeout(elementData.callbackTimer.clock);
                    }
                    applyStyles(elementData.node, elementData.styles.inline.generated);
                    element.removeAttribute("data-sr-id");
                    delete _this.store.elements[id];
                }
            });
        } catch (e) {
            return debuglog.call(this, "Clean failed.", e.message);
        }

        try {
            reset.call(this);
        } catch (e) {
            return debuglog.call(this, "Clean failed.", e.message);
        }
    }
    
    function createMatrix(array) {
        if (array.constructor !== Array) {
            throw new TypeError("Expected array.");
        }
        if (array.length === 16) {
            return array;
        }
        if (array.length !== 6) {
            throw new RangeError("Expected array with either 6 or 16 values.");
        }
        var matrix = createIdentityMatrix();

        matrix[0] = array[0];
        matrix[1] = array[1];
        matrix[4] = array[2];
        matrix[5] = array[3];
        matrix[12] = array[4];
        matrix[13] = array[5];

        return matrix;
    }

    function createIdentityMatrix() {
        var matrix = [];
        for (var i = 0; i < 16; i++) {
            matrix.push(i % 5 === 0 ? 1 : 0);
        }
        return matrix;
    }
    
    function F(matrix1, matrix2) {
        for (var array1 = createMatrix(matrix1), array2 = createMatrix(matrix2), result = [], isNode = 0; isNode < 4; isNode++)
            for (var X = [array1[isNode], array1[isNode + 4], array1[isNode + 8], array1[isNode + 12]], a = 0; a < 4; a++) {
                var c = 4 * a,
                    l = [array2[c], array2[c + 1], array2[c + 2], array2[c + 3]],
                    d = X[0] * l[0] + X[1] * l[1] + X[2] * l[2] + X[3] * l[3];
                result[isNode + c] = d
            }
        return result
    }

    function transformMatrix(x) {
        var matrix = createIdentityMatrix();
        matrix[0] = x;
        matrix[5] = "number" === typeof x ? x : 1;
        return matrix;
    }

    var Style = function() {
        var chace = {},
            style = document.documentElement.style;
    
        function object(property, element) {
            if (element === void 0 && (element = style), property && typeof property == "string") {
                if (chace[property]) {
                    return chace[property];
                }
                if (typeof element[property] == "string") {
                    return chace[property] = property;
                }
                if (typeof element["-webkit-" + property] == "string") {
                    return chace[property] = "-webkit-" + property;
                }
                throw new RangeError('Unable to find "' + property + '" style property.')
            }
            throw new TypeError("Expected a string.")
        }
        return object.clearCache = function() {
            return chace = {}
        }, object
    }();
    
    function applyInStyles(element) {
        var computedStyles = window.getComputedStyle(element.node),
            supportCheck = computedStyles.position,
            i = element.config,
            defaults = {},
            isNode = (element.node.getAttribute("style") || "")
            .match(/[\w-] + \s*:\s*[^;] + \s*/gi) || [];
   
        if (isNode) {
            defaults.computed = isNode.map(function(element) {
                    return element.trim();
                })
                .join("; ") + ";";
        } else
            defaults.computed = "";
   
        defaults.generated = isNode.some(function(object) {
                return object.match(/visibility\s?:\s?visible/i)
            }) ?
            defaults.computed : isNode.concat(["visibility: visible"])
            .map(function(object) {
                return object.trim()
            })
            .join("; ") + ";";
        var X, a, c, l, d, u, f, h, p, m, y, v, g, b = parseFloat(computedStyles.opacity),
            w = isNaN(parseFloat(i.opacity)) ?
            parseFloat(computedStyles.opacity) :
            parseFloat(i.opacity),
   
            E = {
                computed: b !== w ?
                    "opacity: " + b + ";" : "",
                generated: b !== w ?
                    "opacity: " + w + ";" : ""
            },
   
            j = [];
        if (parseFloat(i.distance)) {
            var T = "top" === i.origin || "bottom" === i.origin ? "Y" : "X",
                k = i.distance;
   
            "top" !== i.origin && "left" !== i.origin || (k = /^-/.test(k) ? k.substr(1) : "-" + k);
   
            var O = k.match(/(^-?\d+\.?\d?)|(em$|px$|%$)/g),
                x = O[0];
            switch (O[1]) {
                case "em":
                    k = parseInt(computedStyles.fontSize) * x;
                    break;
                case "px":
                    k = x;
                    break;
                case "%":
                    k = "Y" === T ?
                        object.node.getBoundingClientRect()
                        .height * x / 100 :
                        object.node.getBoundingClientRect()
                        .width * x / 100;
                    break;
                default:
                    throw new RangeError("Unrecognized or missing distance unit.")
            }
   
            "Y" === T
                ?
                j.push((c = k, (l = createIdentityMatrix())[13] = c, l)) :
                j.push((X = k, (a = createIdentityMatrix())[12] = X, a))
        }
   
        i.rotate.x && j.push((d = i.rotate.x, u = Math.PI / 180 * d, (f = createIdentityMatrix())[5] = f[10] = Math.cos(u), f[6] = f[9] = Math.sin(u), f[9] *= -1, f)), i.rotate.y && j.push((h = i.rotate.y, p = Math.PI / 180 * h, (m = createIdentityMatrix())[0] = m[10] = Math.cos(p), m[2] = m[8] = Math.sin(p), m[2] *= -1, m)), i.rotate.createIdentityMatrix && j.push((y = i.rotate.createIdentityMatrix, v = Math.PI / 180 * y, (g = createIdentityMatrix())[0] = g[5] = Math.cos(v), g[1] = g[4] = Math.sin(v), g[4] *= -1, g)),
            1 !== i.scale && (0 === i.scale ? j.push(transformMatrix(2e-4)) : j.push(transformMatrix(i.scale)));
   
        var R = {};
        if (j.length) {
   
            R.property = Style("transform"),
                R.computed = {
                    raw: computedStyles[R.property],
                    matrix: function(object) {
                            if ("string" == typeof object) {
                                var computedStyles = object.match(/matrix(3d)?\(([^)]+)\)/);
                                if (computedStyles)
                                    return createMatrix(computedStyles[2].split(", ")
                                        .map(parseFloat))
                            }
                            return createIdentityMatrix()
                        }
                        (computedStyles[R.property])
                },
   
                j.unshift(R.computed.matrix);
   
            var q = j.reduce(F);
   
            R.generated = {
                initial: R.property + " : matrix3d(" + q.join(", ") + ");",
                final: R.property + " : matrix3d(" + R.computed.matrix.join(", ") + ");"
            }
        } else
            R.generated = {
                initial: "",
                final: ""
            };
   
        var A = {};
   
        if (E.generated || R.generated.initial) {
            A.property = Style("transition"), A.computed = computedStyles[A.property], A.fragments = [];
   
            var P = i.delay,
                L = i.duration,
                M = i.easing;
   
            E.generated && A.fragments.push({
                    delayed: "opacity " + L / 1e3 + "s " + M + " " + P / 1e3 + "s",
                    instant: "opacity " + L / 1e3 + "s " + M + " 0s"
                }),
   
                R.generated.initial && A.fragments.push({
                    delayed: R.property + " " + L / 1e3 + "s " + M + " " + P / 1e3 + "s",
                    instant: R.property + " " + L / 1e3 + "s " + M + " 0s"
                }),
   
                A.computed && !A.computed.match(/all 0s | none 0s/) && A.fragments.unshift({
                    delayed: A.computed,
                    instant: A.computed
                });
   
            var I = A.fragments.reduce(function(object, computedStyles, supportCheck) {
                return object.delayed += 0 === supportCheck ? computedStyles.delayed : ", " + computedStyles.delayed, object.instant += 0 === supportCheck ? computedStyles.instant : ", " + computedStyles.instant, object
            }, {
                delayed: "",
                instant: ""
            });
   
            A.generated = {
                delayed: A.property + ": " + I.delayed + ";",
                instant: A.property + " : " + I.instant + ";"
            }
        } else
            A.generated = {
                delayed: "",
                instant: ""
            };
   
        return {
            inline: defaults,
            opacity: E,
            position: supportCheck,
            transform: R,
            transition: A
        }
    }

    function applyStyles(element, styles) {
        styles.split(";")
            .forEach(function(style) {
                var t = style.split(":"),
                    property = t[0],
                    value = t.slice(1);
                property && value && (element.style[property.trim()] = value.join(":"))
            })
    }
        
    function y(object) {
        var i, defaults = this;
        try {
            forEach(u(object), function(element) {
                var id = element.getAttribute("data-sr-id");
                if (id !== null) {
                    i = !0;
                    var supportCheck = defaults.store.elements[id];
                    supportCheck.callbackTimer && window.clearTimeout(supportCheck.callbackTimer.clock),
                        applyStyles(supportCheck.node, supportCheck.styles.inline.generated),
                        element.removeAttribute("data-sr-id"),
                        delete defaults.store.elements[id]
                }
            })
        } catch (e) {
            return debuglog.call(this, "Clean failed.", e.message)
        }
    
        if (i)
            try {
                t.call(this)
            }
    
        catch (e) {
            return debuglog.call(this, "Clean failed.", e.message)
        }
    }
            
    function v(supportCheck) {
        for (var object = [], t = arguments.length - 1; 0 < t--;)
            object[t] = arguments[t + 1];
    
        if (isObject(supportCheck))
            return forEach(object, function(object) {
                forEach(object, function(object, t) {
                    isObject(object) ? (supportCheck[t] && isObject(supportCheck[t]) || (supportCheck[t] = {}), v(supportCheck[t], object)) : supportCheck[t] = object
                })
            }), supportCheck;
        throw new TypeError("Target must be an object literal.")
    }
    
    function g(object){
        return void 0 === object && (object = navigator.userAgent), /Android|iPhone|iPad|iPod/i.test(object)
    }
    
    var object, b = (object = 0, function() {
        return object++
    });
    
    function w() {
        var supportCheck = this;
        t.call(this),
    
            forEach(this.store.elements, function(object) {
                var t = [object.styles.inline.generated];
                object.visible ?
                    (t.push(object.styles.opacity.computed), t.push(object.styles.transform.generated.final), object.revealed = !0) :
                    (t.push(object.styles.opacity.generated), t.push(object.styles.transform.generated.initial), object.revealed = !1), applyStyles(object.node, t.filter(function(object) {
                            return "" !== object
                        })
                        .join(" "))
            }),
    
            forEach(this.store.containers, function(object) {
                var t = object.node === document.documentElement ?
                    window :
                    object.node;
                t.addEventListener("scroll", supportCheck.delegate), t.addEventListener("resize", supportCheck.delegate)
            }), this.delegate(), this.initTimeout = null
    }
            
    function c(object, t) {
        void 0 === t && (t = {});
        var supportCheck = t.pristine || this.pristine,
            i = "always" === object.config.useDelay || "onload" === object.config.useDelay && supportCheck || "once" === object.config.useDelay && !object.seen,
            defaults = object.visible && !object.revealed,
            isNode = !object.visible && object.revealed && object.config.reset;
    
        return t.reveal || defaults ?
            function(object, t) {
                var supportCheck = [object.styles.inline.generated, object.styles.opacity.computed, object.styles.transform.generated.final];
                t
                    ?
                    supportCheck.push(object.styles.transition.generated.delayed) :
                    supportCheck.push(object.styles.transition.generated.instant);
                object.revealed = object.seen = !0, applyStyles(object.node, supportCheck.filter(function(object) {
                        return "" !== object
                    })
                    .join(" ")), a.call(this, object, t)
            }.call(this, object, i) :
            t.reset || isNode ?
            function(object) {
                var t = [object.styles.inline.generated, object.styles.opacity.generated, object.styles.transform.generated.initial, object.styles.transition.generated.instant];
                object.revealed = !1, applyStyles(object.node, t.filter(function(object) {
                        return "" !== object
                    })
                    .join(" ")), a.call(this, object)
            }.call(this, object) :
            void 0
    }
        
    function a(object, t) {
        var supportCheck = this,
            i = t ?
            object.config.duration + object.config.delay :
            object.config.duration,
            defaults = object.revealed ?
            object.config.beforeReveal :
            object.config.beforeReset,
            isNode = object.revealed ?
            object.config.afterReveal :
            object.config.afterReset,
            X = 0;
        object.callbackTimer && (X = Date.now() - object.callbackTimer.start,
                window.clearTimeout(object.callbackTimer.clock)),
            defaults(object.node),
            object.callbackTimer = {
                start: Date.now(),
                clock: window.setTimeout(function() {
                    isNode(object.node), object.callbackTimer = null, object.revealed && !object.config.reset && object.config.cleanup && y.call(supportCheck, object.node)
                }, i - X)
            }
    }
                
    function l(object, t) {
        if (void 0 === t && (t = this.pristine), !object.visible && object.revealed && object.config.reset)
            return c.call(this, object, {
                reset: !0
            });
    
        var supportCheck = this.store.sequences[object.sequence.id],
            i = object.sequence.index;
    
        if (supportCheck) {
            var defaults = new d(supportCheck, "visible", this.store),
                isNode = new d(supportCheck, "revealed", this.store);
    
            if (supportCheck.models = {
                    visible: defaults,
                    revealed: isNode
                }, !isNode.body.length) {
                var X = supportCheck.members[defaults.body[0]],
                    a = this.store.elements[X];
                if (a)
                    return j.call(this, supportCheck, defaults.body[0], -1, t), j.call(this, supportCheck, defaults.body[0], 1, t), c.call(this, a, {
                        reveal: !0,
                        pristine: t
                    })
            }
    
            if (!supportCheck.blocked.head && i === [].concat(isNode.head)
                .pop() && i >= [].concat(defaults.body)
                .shift())
                return j.call(this, supportCheck, i, -1, t), c.call(this, object, {
                    reveal: !0,
                    pristine: t
                });
    
            if (!supportCheck.blocked.foot && i === [].concat(isNode.foot)
                .shift() && i <= [].concat(defaults.body)
                .pop())
                return j.call(this, supportCheck, i, 1, t), c.call(this, object, {
                    reveal: !0,
                    pristine: t
                })
        }
    }
    
    function E(object) {
        var t = Math.abs(object);
        if (isNaN(t))
            throw new RangeError("Invalid sequence interval.");
        this.id = b(),
            this.interval = Math.max(t, 16),
            this.members = [],
            this.models = {},
            this.blocked = {
                head: !1,
                foot: !1
            }
    }
    
    function d(object, i, defaults) {
        var isNode = this;
        this.head = [],
            this.body = [],
            this.foot = [],
            forEach(object.members, function(object, t) {
                var supportCheck = defaults.elements[object];
                supportCheck && supportCheck[i] && isNode.body.push(t)
            }),
            this.body.length && forEach(object.members, function(object, t) {
                var supportCheck = defaults.elements[object];
                supportCheck && !supportCheck[i] && (t < isNode.body[0] ? isNode.head.push(t) : isNode.foot.push(t))
            })
    }
        
    function j(object, t, supportCheck, i) {
        var defaults = this,
            isNode = ["head", null, "foot"][1 + supportCheck],
            X = object.members[t + supportCheck],
            a = this.store.elements[X];
        object.blocked[isNode] = !0,
            setTimeout(function() {
                    object.blocked[isNode] = !1, a && l.call(defaults, a, i)
                },
                object.interval)
    }
    
    function i(object, a, t) {
        var c = this;
        void 0 === a && (a = {}), void 0 === t && (t = !1);
        var l, d = [],
            supportCheck = a.interval || defaults.interval;
        try {
            supportCheck && (l = new E(supportCheck));
            var i = u(object);
            if (!i.length)
                throw new Error("Invalid reveal target.");
    
            forEach(i.reduce(function(object, t) {
                var supportCheck = {},
                    i = t.getAttribute("data-sr-id");
                i
                    ?
                    (v(supportCheck, c.store.elements[i]), applyStyles(supportCheck.node, supportCheck.styles.inline.computed)) :
                    (supportCheck.id = b(), supportCheck.node = t, supportCheck.seen = !1, supportCheck.revealed = !1, supportCheck.visible = !1);
    
                var defaults = v({}, supportCheck.config || c.defaults, a);
    
                if (!defaults.mobile && g() || !defaults.desktop && !g())
                    return i && y.call(c, supportCheck), object;
    
                var isNode, X = u(defaults.container)[0];
    
                if (!X)
                    throw new Error("Invalid container.");
    
                return X.contains(t) && (null === (isNode = function(t) {
                        var object = [],
                            supportCheck = arguments.length - 1;
                        for (; 0 < supportCheck--;)
                            object[supportCheck] = arguments[supportCheck + 1];
    
                        var i = null;
                        return forEach(object, function(object) {
                            forEach(object, function(object) {
                                null === i && object.node === t && (i = object.id)
                            })
                        }), i
                    }
    
                    (X, d, c.store.containers)) && (isNode = b(), d.push({
                    id: isNode,
                    node: X
                })), supportCheck.config = defaults, supportCheck.containerId = isNode, supportCheck.styles = applyInStyles(supportCheck), l && (supportCheck.sequence = {
                    id: l.id,
                    index: l.members.length
                }, l.members.push(supportCheck.id)), object.push(supportCheck)), object
            }, []), function(object) {
                (c.store.elements[object.id] = object)
                .node.setAttribute("data-sr-id", object.id)
            })
        } catch (object) {
            return debuglog.call(this, "Reveal failed.", object.message)
        }
    
        forEach(d, function(object) {
                c.store.containers[object.id] = {
                    id: object.id,
                    node: object.node
                }
            }), l &&
            (this.store.sequences[l.id] = l), !0 !== t &&
            (this.store.history.push({
                    target: object,
                    options: a
                }),
                this.initTimeout && window.clearTimeout(this.initTimeout),
                this.initTimeout = window.setTimeout(w.bind(this), 0))
    }
    
    var T, k = Math.sign || function(object) {
            return (0 < object) - (object < 0) || +object
        },
        O = (T = Date.now(), function(object) {
            var t = Date.now();
            16 < t - T ?
                object(T = t) :
                setTimeout(function() {
                    return O(object)
                }, 0)
        }),
        x = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame || O;
        
    function R(object, t) {
        for (var supportCheck = t ? object.node.clientHeight : object.node.offsetHeight, i = t ? object.node.clientWidth : object.node.offsetWidth, defaults = 0, isNode = 0,
                X = object.node; isNaN(X.offsetTop) || (defaults += X.offsetTop), isNaN(X.offsetLeft) || (isNode += X.offsetLeft), X = X.offsetParent;);
        return {
            bounds: {
                top: defaults,
                right: isNode + i,
                bottom: defaults + supportCheck,
                left: isNode
            },
            height: supportCheck,
            width: i
        }
    }
                
    function q(object, t) {
        var i = this;
        void 0 === object && (object = {
                type: "init"
            }),
            void 0 === t && (t = this.store.elements), x(function() {
                var supportCheck = "init" === object.type || "resize" === object.type;
                forEach(i.store.containers, function(object) {
                        supportCheck && (object.geometry = R.call(i, object, !0));
                        var t = function(object) {
                            var t, supportCheck;
                            return supportCheck = object.node === document.documentElement ?
                                (t = window.pageYOffset, window.pageXOffset) :
                                (t = object.node.scrollTop, object.node.scrollLeft), {
                                    top: t,
                                    left: supportCheck
                                }
                        }.call(i, object);
                        object.scroll && (object.direction = {
                            x: k(t.left - object.scroll.left),
                            y: k(t.top - object.scroll.top)
                        }), object.scroll = t
                    }),
                    forEach(t, function(object) {
                        (supportCheck || void 0 === object.geometry) && (object.geometry = R.call(i, object)), object.visible = function(object) {
                            void 0 === object && (object = {});
                            var t = this.store.containers[object.containerId];
                            if (t) {
                                var supportCheck = Math.max(0, Math.min(1, object.config.viewFactor)),
                                    i = object.config.viewOffset,
                                    defaults = object.geometry.bounds.top + object.geometry.height * supportCheck,
                                    isNode = object.geometry.bounds.right - object.geometry.width * supportCheck,
                                    X = object.geometry.bounds.bottom - object.geometry.height * supportCheck,
                                    a = object.geometry.bounds.left + object.geometry.width * supportCheck,
                                    c = t.geometry.bounds.top + t.scroll.top + i.top,
                                    l = t.geometry.bounds.right + t.scroll.left - i.right,
                                    d = t.geometry.bounds.bottom + t.scroll.top - i.bottom,
                                    u = t.geometry.bounds.left + t.scroll.left + i.left;
                                return defaults < d && u < isNode && c < X && a < l || "fixed" === object.styles.position
                            }
                        }.call(i, object)
                    }),
                    forEach(t, function(object) {
                        object.sequence ?
                            l.call(i, object) :
                            c.call(i, object)
                    }),
                    i.pristine = !1
            })
    }
                
    var A, P, L, M, I, C, W, Y, $ = "4.0.9";

function H(object) {
    var t;
    if (void 0 === object && (object = {}), void 0 === this || Object.getPrototypeOf(this) !== H.prototype)
        return new H(object);

    if (!H.isSupported())
        return debuglog.call(this, "Instantiation failed.", "This browser is not supported."), supportCheck.failure();

    try {
        t = v({}, C || defaults, object)
    } catch (object) {
        return debuglog.call(this, "Invalid configuration.", object.message), supportCheck.failure()
    }

    try {
        if (!u(t.container)[0])
            throw new Error("Invalid container.")
    } catch (object) {
        return debuglog.call(this, object.message), supportCheck.failure()
    }
    return !(C = t)
        .mobile && g() || !C.desktop && !g() ?
        (debuglog.call(this, "This device is disabled.", "desktop: " + C.desktop, "mobile: " + C.mobile), supportCheck.failure()) :
        (supportCheck.success(), this.store = {
                containers: {},
                elements: {},
                history: [],
                sequences: {}
            },
            this.pristine = !0, A = A || q.bind(this), P = P || function() {
                var supportCheck = this;
                forEach(this.store.elements, function(object) {
                        applyStyles(object.node, object.styles.inline.generated), object.node.removeAttribute("data-sr-id")
                    }),
                    forEach(this.store.containers, function(object) {
                        var t = object.node === document.documentElement ?
                            window :
                            object.node;
                        t.removeEventListener("scroll", supportCheck.delegate), t.removeEventListener("resize", supportCheck.delegate)
                    }),
                    this.store = {
                        containers: {},
                        elements: {},
                        history: [],
                        sequences: {}
                    }
            }.bind(this), L = L || i.bind(this), M = M || y.bind(this), I = I || function() {
                var t = this;
                forEach(this.store.history, function(object) {
                    i.call(t, object.target, object.options, !0)
                }), w.call(this)
            }
            .bind(this), Object.defineProperty(this, "delegate", {
                get: function() {
                    return A
                }
            }),
            Object.defineProperty(this, "destroy", {
                get: function() {
                    return P
                }
            }),
            Object.defineProperty(this, "reveal", {
                get: function() {
                    return L
                }
            }),
            Object.defineProperty(this, "clean", {
                get: function() {
                    return M
                }
            }),
            Object.defineProperty(this, "sync", {
                get: function() {
                    return I
                }
            }),
            Object.defineProperty(this, "defaults", {
                get: function() {
                    return C
                }
            }),
            Object.defineProperty(this, "version", {
                get: function() {
                    return $
                }
            }),
            Object.defineProperty(this, "noop", {
                get: function() {
                    return !1
                }
            }),
            Y || (Y = this))
    }
    return H.isSupported = function() {
        return ("transform" in (t = document.documentElement.style) ||
                "WebkitTransform" in t) &&
            ("transition" in (object = document.documentElement.style) ||
                "WebkitTransition" in object);
        var object, t
    },
    Object.defineProperty(H, "debug", {
        get: function() {
            return W || !1
        },
        set: function(object) {
            return W = "boolean" == typeof object ?
                object : W
        }
    }), H(), H
}();